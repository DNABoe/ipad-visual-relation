<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Grid Analysis</title>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #0a0a0a;
      color: #e0e0e0;
    }
    button {
      background: #0ea5e9;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 6px;
      cursor: pointer;
      margin-bottom: 20px;
    }
    button:hover {
      background: #0284c7;
    }
    button:disabled {
      background: #334155;
      cursor: not-allowed;
    }
    #result {
      background: #1a1a1a;
      padding: 20px;
      border-radius: 8px;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.6;
      max-height: 800px;
      overflow-y: auto;
    }
    h1 {
      color: #0ea5e9;
    }
  </style>
</head>
<body>
  <h1>Grid Toggle & Canvas Settings Analysis</h1>
  <p>Click the button below to have an AI analyze the grid toggle and canvas settings code for potential issues.</p>
  <button id="analyzeBtn" onclick="runAnalysis()">Run Analysis</button>
  <div id="result"></div>

  <script type="module">
    window.runAnalysis = async function() {
      const btn = document.getElementById('analyzeBtn')
      const resultDiv = document.getElementById('result')
      
      btn.disabled = true
      btn.textContent = 'Analyzing...'
      resultDiv.textContent = 'Analysis in progress...'

      const codeContext = \`
# Grid Toggle and Canvas Settings Analysis

## Issue Description
There are potential problems with the grid toggle button and canvas settings not working properly.

## Code Components

### 1. WorkspaceToolbar.tsx (Grid Toggle)
\\\`\\\`\\\`typescript
const [settings, setSettings] = useKV<AppSettings>('app-settings', DEFAULT_APP_SETTINGS)
const showGrid = settings?.showGrid ?? true

const toggleGrid = async () => {
  const newValue = !showGrid
  await setSettings((current) => ({ ...DEFAULT_APP_SETTINGS, ...current, showGrid: newValue }))
  await new Promise(resolve => setTimeout(resolve, 100))
  window.dispatchEvent(new CustomEvent('settings-changed'))
  onRefreshCanvas()
  toast.success(newValue ? 'Grid enabled' : 'Grid disabled')
}
\\\`\\\`\\\`

### 2. SettingsDialog.tsx (Settings Panel)
\\\`\\\`\\\`typescript
const [appSettings, setAppSettings] = useKV<AppSettings>('app-settings', DEFAULT_APP_SETTINGS)

<Switch
  id="show-grid-toggle"
  checked={appSettings?.showGrid ?? true}
  onCheckedChange={async (checked) => {
    await setAppSettings((current) => ({ ...DEFAULT_APP_SETTINGS, ...current, showGrid: checked }))
    window.dispatchEvent(new CustomEvent('settings-changed'))
    onRefreshCanvas?.()
    toast.success(checked ? 'Grid enabled' : 'Grid disabled')
  }}
/>
\\\`\\\`\\\`

### 3. WorkspaceCanvas.tsx (Grid Rendering)
\\\`\\\`\\\`typescript
const [settings] = useKV<AppSettings>('app-settings', DEFAULT_APP_SETTINGS)
const [previousShowGrid, setPreviousShowGrid] = useState<boolean | undefined>(undefined)
const [forceUpdateKey, setForceUpdateKey] = useState(0)

const showGrid = settings?.showGrid ?? DEFAULT_APP_SETTINGS.showGrid
const gridSize = settings?.gridSize ?? DEFAULT_APP_SETTINGS.gridSize
const gridOpacity = settings?.gridOpacity ?? DEFAULT_APP_SETTINGS.gridOpacity

useEffect(() => {
  const handleSettingsChange = () => {
    setForceUpdateKey(prev => prev + 1)
  }
  
  window.addEventListener('settings-changed', handleSettingsChange)
  return () => window.removeEventListener('settings-changed', handleSettingsChange)
}, [])

useEffect(() => {
  setForceUpdateKey(prev => prev + 1)
}, [settings?.showGrid, settings?.gridSize, settings?.gridOpacity, settings?.snapToGrid, settings?.organicLines])

useEffect(() => {
  const canvas = controller.canvasRef.current
  if (!canvas) return

  const { x, y, scale } = controller.transform.transform
  const scaledGridSize = gridSize * scale
  
  canvas.style.setProperty('--grid-size', \\\`\\\${scaledGridSize}px\\\`)
  canvas.style.setProperty('--grid-opacity', \\\`\\\${gridOpacity / 100}\\\`)
  canvas.style.setProperty('--grid-x', \\\`\\\${x}px\\\`)
  canvas.style.setProperty('--grid-y', \\\`\\\${y}px\\\`)
  
  if (showGrid) {
    if (previousShowGrid === false) {
      canvas.classList.remove('canvas-grid-fade-out')
      canvas.classList.add('canvas-grid')
      void canvas.offsetHeight
      canvas.classList.add('canvas-grid-fade-in')
      
      const timeout = setTimeout(() => {
        canvas.classList.remove('canvas-grid-fade-in')
      }, 350)
      
      setPreviousShowGrid(true)
      return () => clearTimeout(timeout)
    } else if (previousShowGrid === undefined) {
      canvas.classList.add('canvas-grid')
      setPreviousShowGrid(true)
    } else {
      canvas.classList.add('canvas-grid')
      canvas.classList.remove('canvas-grid-fade-in', 'canvas-grid-fade-out')
    }
  } else {
    if (previousShowGrid === true) {
      canvas.classList.add('canvas-grid-fade-out')
      
      const timeout = setTimeout(() => {
        canvas.classList.remove('canvas-grid', 'canvas-grid-fade-out')
      }, 350)
      
      setPreviousShowGrid(false)
      return () => clearTimeout(timeout)
    } else if (previousShowGrid === undefined) {
      canvas.classList.remove('canvas-grid', 'canvas-grid-fade-in', 'canvas-grid-fade-out')
      setPreviousShowGrid(false)
    } else {
      canvas.classList.remove('canvas-grid', 'canvas-grid-fade-in', 'canvas-grid-fade-out')
    }
  }
}, [gridSize, showGrid, gridOpacity, controller.transform.transform.x, controller.transform.transform.y, controller.transform.transform.scale, controller.canvasRef, previousShowGrid, forceUpdateKey])
\\\`\\\`\\\`

### 4. CSS (index.css)
\\\`\\\`\\\`css
.canvas-grid {
  background-color: var(--canvas-bg);
  position: relative;
}

.canvas-grid::before {
  content: '';
  position: absolute;
  inset: 0;
  background-image: 
    linear-gradient(to right, oklch(0.88 0.18 185 / var(--grid-opacity, 0.15)) 1px, transparent 1px),
    linear-gradient(to bottom, oklch(0.88 0.18 185 / var(--grid-opacity, 0.15)) 1px, transparent 1px);
  background-size: var(--grid-size, 20px) var(--grid-size, 20px);
  background-position: var(--grid-x, 0) var(--grid-y, 0);
  pointer-events: none;
  opacity: 1;
  z-index: 0;
}
\\\`\\\`\\\`

### 5. Data Flow
- useKV hook with key 'app-settings' stores settings
- DEFAULT_APP_SETTINGS provides fallback values
- WorkspaceToolbar and SettingsDialog both modify settings
- WorkspaceCanvas reads settings and renders grid
- Custom 'settings-changed' event triggers canvas updates

## Questions to Analyze

1. **Race Conditions**: Are there race conditions between the multiple useKV hooks reading/writing 'app-settings'?
2. **Stale Closures**: Could the toggle function be capturing stale values of 'settings'?
3. **Update Timing**: Is the 100ms delay in toggleGrid sufficient or could it cause issues?
4. **Event Propagation**: Is the custom 'settings-changed' event being properly received?
5. **Default Values**: Could the spreading of DEFAULT_APP_SETTINGS be overwriting user changes?
6. **State Synchronization**: Are the three components (Toolbar, Settings, Canvas) staying in sync?
7. **CSS Application**: Could the CSS classes not be applied properly due to timing issues?
8. **forceUpdateKey**: Is the forceUpdateKey mechanism working correctly to force re-renders?
9. **Multiple Updates**: What happens when both the dialog and toolbar try to update settings simultaneously?
10. **Functional Updates**: Should setSettings use functional updates consistently?

Please provide a comprehensive analysis identifying:
- All potential bugs and race conditions
- Root causes of why grid toggle might not work
- Specific code patterns that could fail
- Recommendations for fixes with code examples
- Priority order of issues to address (highest priority first)
\`

      try {
        const result = await window.spark.llm(codeContext, 'gpt-4o')
        resultDiv.textContent = result
      } catch (error) {
        resultDiv.textContent = 'Error running analysis: ' + error.message
      } finally {
        btn.disabled = false
        btn.textContent = 'Run Analysis Again'
      }
    }
  </script>
</body>
</html>
